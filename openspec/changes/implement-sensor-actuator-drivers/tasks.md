# 任务清单：实现传感器和执行器驱动（第二阶段）

本阶段聚焦于将传感器和执行器的桩函数替换为真实的硬件驱动实现，使系统能够在实际设备上运行并完成核心功能。

---

## 阶段 0：准备工作

### Task 0.1：修复 fan_control.c 编码问题

**目标**：将 `main/actuators/fan_control.c` 重新保存为 UTF-8(无BOM)，恢复所有中文注释和日志的正确显示。

**操作**：
1. 使用文本编辑器或命令行工具将文件转换为 UTF-8 编码
2. 恢复以下内容的中文：
   - 文件头注释（第 3 行）
   - 函数文档注释（第 14-17、27-30 行）
   - 日志输出（第 43、54、61 行）

**交付物**：
- 编码正确的 `main/actuators/fan_control.c`

**验证**：
```bash
file main/actuators/fan_control.c  # 应显示 UTF-8
cat main/actuators/fan_control.c | head -20  # 中文注释正确显示
```

**依赖**：无

**优先级**：高（影响后续代码审查和维护）

---

## 阶段 1：CO₂ 传感器驱动实现

### Task 1.1：研究 JX-CO2-102-5K 通信协议

**目标**：确定 CO₂ 传感器的 UART 帧格式和解析方法。

**操作**：
1. 使用 exa MCP 搜索 JX-CO2-102-5K 官方文档或技术规格
2. 确认主动上报模式的帧格式（已知格式：`CO2:1234\r\n`，需验证）
3. 确认数据范围和单位（预期：400-5000 ppm）
4. 确认错误处理方法（无效数据、通信超时）

**交付物**：
- 技术摘要记录在 `.claude/context-claude.md` 或任务注释中

**验证**：
- 能够准确描述帧格式、字段含义和解析规则

**依赖**：无

**优先级**：高

---

### Task 1.2：实现 UART 接收缓冲区和帧解析

**目标**：在 `co2_sensor.c` 中实现 `co2_sensor_read_ppm()` 函数，从 UART 读取并解析 CO₂ 数据。

**实现内容**：
1. 使用 `uart_read_bytes()` 从 UART 缓冲区读取数据（超时 100ms）
2. 查找帧起始标志（`CO2:`）和结束标志（`\r\n`）
3. 提取数值字符串并转换为 float（使用 `atof()` 或 `strtof()`）
4. 数据验证：
   - 范围检查：400-5000 ppm（超出范围返回 -1.0f）
   - 格式检查：确保包含有效数字
5. 错误处理：
   - UART 读取失败：返回 -1.0f，打印 ERROR 日志
   - 无效数据：返回 -1.0f，打印 WARN 日志
   - 超时（无数据）：返回 -1.0f

**代码位置**：
- `main/sensors/co2_sensor.c:62-66`（替换当前 TODO）

**交付物**：
- 完整的 `co2_sensor_read_ppm()` 函数实现

**验证**：
```bash
idf.py build  # 编译通过
# 硬件验证（由用户执行）：
# 1. 烧录固件到设备
# 2. 运行 idf.py monitor，观察日志输出
# 3. 确认 CO₂ 读数与手持测量仪一致（误差 ±50 ppm）
```

**依赖**：Task 1.1

**优先级**：高

---

### Task 1.3：更新 sensor_manager 错误处理

**目标**：确保 `sensor_manager_read_all()` 正确处理 CO₂ 传感器返回 -1.0f 的情况。

**操作**：
1. 检查 `main/sensors/sensor_manager.c:47-63` 的 CO₂ 读取逻辑
2. 确认 `-1.0f` 会触发失败计数器增加
3. 如果逻辑不正确，修正错误处理

**交付物**：
- 验证报告或修正代码

**验证**：
- 模拟传感器故障（断开 UART 连接），确认系统进入 ERROR 状态

**依赖**：Task 1.2

**优先级**：中

---

## 阶段 2：SHT35 温湿度传感器驱动实现

### Task 2.1：研究 SHT35 I2C 协议

**目标**：确定 SHT35 的 I2C 命令序列、数据格式和 CRC 校验方法。

**操作**：
1. 使用 exa MCP 搜索 SHT35 官方数据手册
2. 确认以下信息：
   - I2C 设备地址（已知：0x44）
   - 测量命令（单次测量模式 vs 周期测量模式）
   - 命令字节序列（高字节在前还是低字节在前）
   - 数据读取时序（发送命令 → 延迟 → 读取数据）
   - CRC-8 校验多项式和计算方法
   - 温湿度原始数据到物理值的转换公式

**交付物**：
- 技术摘要记录在 `.claude/context-claude.md` 或任务注释中

**验证**：
- 能够准确描述命令序列、延迟时间、转换公式

**依赖**：无

**优先级**：高

---

### Task 2.2：实现 I2C 总线初始化

**目标**：在 `sht35_init()` 中初始化 I2C 主机模式，配置 GPIO21/22。

**实现内容**：
1. 配置 I2C 主机模式：
   ```c
   i2c_config_t conf = {
       .mode = I2C_MODE_MASTER,
       .sda_io_num = GPIO_NUM_21,
       .scl_io_num = GPIO_NUM_22,
       .sda_pullup_en = GPIO_PULLUP_ENABLE,
       .scl_pullup_en = GPIO_PULLUP_ENABLE,
       .master.clk_speed = 100000,  // 100kHz
   };
   i2c_param_config(I2C_NUM_0, &conf);
   i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);
   ```
2. 错误处理：初始化失败时返回 `ESP_FAIL` 并打印错误日志
3. 防止重复初始化：使用静态变量 `s_i2c_ready` 标记

**代码位置**：
- `main/sensors/sht35.c:11-15`（替换当前 TODO）

**交付物**：
- 完整的 `sht35_init()` 函数实现

**验证**：
```bash
idf.py build  # 编译通过
# 硬件验证（由用户执行）：
# 1. 使用 i2c-tools 扫描设备：i2cdetect -y 0
# 2. 确认地址 0x44 被检测到
```

**依赖**：Task 2.1

**优先级**：高

---

### Task 2.3：实现 SHT35 数据读取和校验

**目标**：在 `sht35_read()` 中实现完整的测量命令序列、数据读取和 CRC 校验。

**实现内容**：
1. 获取 I2C 互斥锁（使用 `get_i2c_mutex()`，超时 100ms）
2. 发送单次测量命令（根据 Task 2.1 确定的命令字节）
3. 延迟等待测量完成（根据数据手册，通常 15-20ms）
4. 读取 6 字节数据：
   - 字节 0-1：温度原始值（16-bit）
   - 字节 2：温度 CRC-8
   - 字节 3-4：湿度原始值（16-bit）
   - 字节 5：湿度 CRC-8
5. 验证 CRC 校验和：
   - 实现 `crc8_compute()` 辅助函数（根据 SHT35 多项式：0x31）
   - 校验失败：释放锁，返回 `ESP_ERR_INVALID_CRC`
6. 转换为物理值：
   - 温度：`-45 + 175 * (raw_temp / 65535.0)`
   - 湿度：`100 * (raw_humi / 65535.0)`
7. 释放 I2C 互斥锁
8. 返回 `ESP_OK`

**代码位置**：
- `main/sensors/sht35.c:17-23`（替换当前 TODO）

**交付物**：
- 完整的 `sht35_read()` 函数实现
- `crc8_compute()` 辅助函数

**验证**：
```bash
idf.py build  # 编译通过
# 硬件验证（由用户执行）：
# 1. 观察串口日志，确认温湿度读数合理（20-30°C, 30-70%）
# 2. 对比环境温度计验证准确性
```

**依赖**：Task 2.2

**优先级**：高

---

### Task 2.4：处理 I2C 通信错误

**目标**：在 `sht35_read()` 中添加完善的错误处理和重试逻辑。

**实现内容**：
1. I2C 超时处理：如果 `i2c_master_cmd_begin()` 返回超时，打印 ERROR 日志并返回 `ESP_ERR_TIMEOUT`
2. 设备未应答处理：返回 `ESP_FAIL` 并打印 WARN 日志
3. 互斥锁获取失败：打印 ERROR 日志，返回 `ESP_ERR_TIMEOUT`
4. CRC 校验失败：打印 WARN 日志，返回 `ESP_ERR_INVALID_CRC`

**交付物**：
- 增强的错误处理代码

**验证**：
- 断开 SHT35 连接，确认日志输出正确的错误信息

**依赖**：Task 2.3

**优先级**：中

---

## 阶段 3：风扇 PWM 控制实现

### Task 3.1：实现 LEDC PWM 初始化

**目标**：在 `fan_control_init()` 中配置 LEDC 外设，初始化 PWM 输出。

**实现内容**：
1. 配置 LEDC 定时器：
   ```c
   ledc_timer_config_t timer_cfg = {
       .speed_mode = LEDC_LOW_SPEED_MODE,
       .duty_resolution = LEDC_TIMER_8_BIT,  // 8-bit (0-255)
       .timer_num = LEDC_TIMER_0,
       .freq_hz = 25000,  // 25kHz
       .clk_cfg = LEDC_AUTO_CLK
   };
   ledc_timer_config(&timer_cfg);
   ```
2. 配置 LEDC 通道：
   ```c
   ledc_channel_config_t channel_cfg = {
       .gpio_num = GPIO_NUM_25,
       .speed_mode = LEDC_LOW_SPEED_MODE,
       .channel = LEDC_CHANNEL_0,
       .timer_sel = LEDC_TIMER_0,
       .duty = 0,  // 初始占空比 0（关闭）
       .hpoint = 0
   };
   ledc_channel_config(&channel_cfg);
   ```
3. 错误处理：配置失败时返回错误码并打印日志
4. 防止重复初始化：检查静态标志

**代码位置**：
- `main/actuators/fan_control.c:42-48`（替换当前 TODO）

**交付物**：
- 完整的 `fan_control_init()` 函数实现

**验证**：
```bash
idf.py build  # 编译通过
# 硬件验证（由用户执行）：
# 1. 使用示波器测量 GPIO25 输出，确认频率为 25kHz
# 2. 初始占空比为 0
```

**依赖**：Task 0.1（编码修复完成后便于阅读代码）

**优先级**：高

---

### Task 3.2：实现 PWM 占空比设置

**目标**：在 `fan_control_set_state()` 和 `fan_control_set_pwm()` 中实现真实的 PWM 输出。

**实现内容**：
1. 在 `fan_control_set_state()` 中（第 50-57 行）：
   - 在计算 PWM 值后，调用 `ledc_set_duty()` 和 `ledc_update_duty()`
   - 错误处理：LEDC 调用失败时返回错误码
2. 在 `fan_control_set_pwm()` 中（第 59-64 行）：
   - 在 PWM 值限幅后，调用 `ledc_set_duty()` 和 `ledc_update_duty()`
3. 日志优化：将 LOGI 改为 LOGD（减少日志量）

**代码位置**：
- `main/actuators/fan_control.c:50-64`（替换当前 TODO）

**交付物**：
- 完整的 PWM 设置逻辑

**验证**：
```bash
idf.py build  # 编译通过
# 硬件验证（由用户执行）：
# 1. 运行系统，观察风扇按 OFF/LOW/HIGH 三档运行
# 2. 使用示波器确认占空比与状态映射一致：
#    - OFF: 0
#    - LOW (白天): 180/255 ≈ 70%
#    - HIGH (白天): 255/255 = 100%
# 3. 用测速仪确认转速变化
```

**依赖**：Task 3.1

**优先级**：高

---

### Task 3.3：验证 PWM 范围保护

**目标**：确认 `fan_clamp_pwm()` 函数在实际运行中正确工作。

**操作**：
1. 检查 `fan_clamp_pwm()` 逻辑（第 19-24 行）
2. 添加单元测试或日志验证：
   - 输入 0 → 输出 0
   - 输入 100 → 输出 150（下限保护）
   - 输入 200 → 输出 200（正常）
   - 输入 300 → 输出 255（上限保护）

**交付物**：
- 验证报告或单元测试

**验证**：
- 所有边界条件通过

**依赖**：Task 3.2

**优先级**：低

---

## 阶段 4：集成验证

### Task 4.1：编译和静态检查

**目标**：确保所有代码编译通过，无警告和错误。

**操作**：
```bash
cd /home/hyperlovimia/esp32/Refresh
. $HOME/esp/v5.5.1/esp-idf/export.sh
idf.py fullclean
idf.py build
```

**验证标准**：
- [ ] 编译成功，无错误
- [ ] 无编译警告（除非是已知的第三方库警告）
- [ ] 生成的 .bin 文件大小合理（<500KB）

**交付物**：
- 成功编译的固件（build/Refresh.bin）

**依赖**：Task 1.2, 2.3, 3.2

**优先级**：高

---

### Task 4.2：硬件功能测试（由用户执行）

**目标**：在实际硬件上验证传感器和执行器的完整功能。

**测试步骤**：

**1. 传感器测试**
```bash
idf.py -p /dev/ttyACM0 flash monitor
```
- 观察串口日志，确认以下信息：
  - [ ] CO₂ 传感器初始化成功（`CO2 UART 初始化完成`）
  - [ ] SHT35 传感器初始化成功（`初始化 SHT35 温度湿度传感器`）
  - [ ] 风扇控制初始化成功（`初始化风扇控制`）
- 等待 60 秒预热完成后，检查传感器读数：
  - [ ] CO₂ 浓度在合理范围（400-2000 ppm）
  - [ ] 温度在合理范围（15-35°C）
  - [ ] 湿度在合理范围（20-80%）

**2. 风扇控制测试**
- 手动触发高 CO₂ 状态（向传感器吹气）：
  - [ ] CO₂ 浓度上升到 >1500 ppm
  - [ ] 日志显示 `状态转换: RUNNING -> RUNNING, 风扇: HIGH`
  - [ ] 风扇转速提高（听觉或测速仪验证）
- 等待 CO₂ 浓度下降：
  - [ ] CO₂ 浓度降低到 <1000 ppm
  - [ ] 日志显示 `状态转换: RUNNING -> RUNNING, 风扇: OFF`
  - [ ] 风扇停止运转

**3. 错误恢复测试**
- 断开 SHT35 连接（拔掉杜邦线）：
  - [ ] 系统检测到传感器故障，进入 `STATE_ERROR`
  - [ ] 日志显示 `传感器故障，进入 ERROR 状态`
- 重新连接 SHT35：
  - [ ] 系统自动恢复到 `STATE_RUNNING`（约 5 分钟）
  - [ ] 日志显示 `传感器恢复，重新初始化`

**交付物**：
- 用户提供的测试结果截图或日志
- 问题列表（如有）

**依赖**：Task 4.1

**优先级**：高

---

### Task 4.3：更新操作日志

**目标**：将本阶段的修改记录到 `.claude/operations-log.md`，便于追溯和审查。

**操作**：
1. 在 `.claude/operations-log.md` 新增章节 `## 2025-12-01 实现传感器和执行器驱动（第二阶段）`
2. 记录以下内容：
   - 变更概述
   - 修改文件清单（文件路径、关键修改点、行号范围）
   - 验证结果（编译结果、硬件测试结果）
   - 问题记录（如有）
   - 下一步计划

**交付物**：
- 更新后的 `.claude/operations-log.md`

**验证**：
- 日志内容完整、清晰、可追溯

**依赖**：Task 4.2

**优先级**：中

---

## 任务执行顺序

按照依赖关系，建议执行顺序：

```
Task 0.1 (修复编码)
  ↓
Task 1.1 (研究 CO₂ 协议) ←─┐
  ↓                        │
Task 1.2 (实现 CO₂ 读取)   │
  ↓                        │
Task 1.3 (更新错误处理)    │  (可并行)
                          │
Task 2.1 (研究 SHT35 协议)←┤
  ↓                        │
Task 2.2 (初始化 I2C)      │
  ↓                        │
Task 2.3 (实现 SHT35 读取) │
  ↓                        │
Task 2.4 (错误处理)        │
                          │
Task 3.1 (初始化 PWM) ←────┘
  ↓
Task 3.2 (实现 PWM 设置)
  ↓
Task 3.3 (验证范围保护)
  ↓
Task 4.1 (编译验证) ←─ 汇总所有模块
  ↓
Task 4.2 (硬件测试)
  ↓
Task 4.3 (更新日志)
```

**并行任务**：Task 1.1、2.1、3.1 可以并行研究（不同模块独立）

**关键路径**：Task 0.1 → Task 1.1 → Task 1.2 → Task 4.1 → Task 4.2

**总耗时估算**：
- 准备阶段：10 分钟（编码修复）
- 研究阶段：30 分钟（查找文档）
- 实现阶段：2 小时（三个驱动）
- 验证阶段：1 小时（编译 + 硬件测试）
- **总计**：约 3.5-4 小时

---

## 验收标准（第二阶段）

- [ ] Task 0.1-3.3 全部完成
- [ ] 代码编译通过，无警告
- [ ] fan_control.c 中文注释正确显示
- [ ] 三个驱动模块（CO₂、SHT35、PWM）功能正确
- [ ] 硬件测试通过（传感器读数准确，风扇响应正确）
- [ ] 错误恢复流程验证通过
- [ ] 操作日志已更新

---

## 后续阶段任务（不在本次范围内）

### 第三阶段：决策算法实现
- 实现完整决策引擎（Benefit-Cost 模型）
- 实现本地自主决策模式
- 算法单元测试

### 第四阶段：网络服务集成
- 实现 WiFi 配网功能
- 实现和风天气 API 客户端（HTTPS）
- 实现 MQTT 客户端（TLS）
- 网络降级和缓存策略

### 第五阶段：用户界面实现
- 集成 u8g2 库
- 实现 OLED 主页面显示
- 实现趋势图绘制
- 实现告警页面

### 第六阶段：系统集成测试
- 完整功能测试
- 长期稳定性测试（7天×24小时）
- 性能优化
